#!/usr/bin/env python
# -*- coding: utf8 -*-
# 
# © 2013-2014 Institute of Mathematics and Computer Science, University of Latvia
# (LU aģentūra "Latvijas Universitātes Matemātikas un informātikas institūts")
#
# All rights reserved.

import sys
from collections import defaultdict

sys.path.append("./src")
from db_config import api_conn_info
from SemanticApiPostgres import SemanticApiPostgres, PostgresConnection
import Relationships

relationship_dataset = 23 # Patvaļīgs numurs, pēc kā tiks identificēti šīs programmas radītie freimi lai tos pie pārrēķināšanas iztīrītu

class Entity:
	def __init__(self):
		self.name = ''
		self.links_from = []
		self.links_to = []		
	def __str__(self):	
		return self.name.encode('utf8')			
		# return ('%s\nout:\t%s\nin:\t%s' % (self.name, self.links_from, self.links_to)).encode('utf8')

def fetch_relations():
	sql = """
SELECT f.frameid, f.dataset, f.blessed,
	relation.entityid AS relationid, relation.name AS relationname,
	p1.entityid AS p1id, p1.name AS p1name,
	p2.entityid AS p2id, p2.name AS p2name
FROM frames f
JOIN (SELECT frameid, e.entityid, NAME FROM framedata d JOIN entities e ON d.entityid = e.entityid WHERE roleid=4) 
	relation ON f.frameid = relation.frameid
JOIN (SELECT frameid, e.entityid, NAME FROM framedata d JOIN entities e ON d.entityid = e.entityid WHERE roleid=1) 
	p1 ON f.frameid = p1.frameid
JOIN (SELECT frameid, e.entityid, NAME FROM framedata d JOIN entities e ON d.entityid = e.entityid WHERE roleid=2) 
	p2 ON f.frameid = p2.frameid
WHERE frametypeid = 3 and not deleted
"""
	res = api.api.query(sql, None)
	entities = defaultdict(Entity)
	for row in res:
		p1 = entities[row.p1id]
		p2 = entities[row.p2id]
		p1.name = row.p1name
		p2.name = row.p2name
		
		autogenerated = False
		if row.dataset == relationship_dataset and not row.blessed:
			autogenerated = True

		link = (p1,p2,row.relationname, autogenerated)
		p1.links_from.append(link)
		p2.links_to.append(link)

	return entities

def analyze_entities(entities):
	rel1 = defaultdict(int)
	rel2 = defaultdict(int)
	rel3 = defaultdict(int)
	rel4 = defaultdict(int)

	for _, a in entities.iteritems():
		for firstlink in a.links_from:
			b = firstlink[1]
			for secondlink in b.links_from:
				c = secondlink[1]
				if a==c:
					description = '%s<->%s' % (firstlink[2], secondlink[2])
					rel4[description] += 1
				else:
					description = '%s->%s' % (firstlink[2], secondlink[2])
					for directlink in a.links_from:
						if directlink[1]==c:
							description = '%s->%s (%s)' % (firstlink[2], secondlink[2], directlink[2])
					rel1[description] += 1
				# print('%s -> %s -> %s  .... (%s->%s)' % (a.name, b.name, c.name, firstlink[2], secondlink[2]))

			# for secondlink in b.links_from:
			# 	c = secondlink[1]
			# 	print('%s -> %s -> %s  .... (%s->%s)' % (a.name, b.name, c.name, firstlink[2], secondlink[2]))

			# for secondlink in a.links_from:
			# 	e = secondlink[1]
		# break

	for rel in sorted(rel1):
		count = rel1[rel]
		if count>=1:
			print('%s : %d' % (rel, count))	

def create_relationships(entities, entityid):
	print(entities[entityid])

def check_entities():
	for rel, val in Relationships.inverted_relations.items():
		print(rel, val)

def main():
	Relationships.fetch_relations(api)
	# entities = fetch_relations()
	# analyze_entities(entities)
	# create_relationships(entities, 2216003) # Vilis Krištopans
	check_entities()
	print('Done!')

if __name__ == "__main__":
	api_conn_info['dbname'] = 'radinieki_test'
	conn = PostgresConnection(api_conn_info, dataset=relationship_dataset) 
	api = SemanticApiPostgres(conn)

	main()